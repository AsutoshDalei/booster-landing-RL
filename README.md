# SpaceX Landing Simulator

A physics-based demonstration of propulsive landing logic, autopilot stabilization, and trajectory guidance. This simulation showcases the control theory principles used to land Falcon-class boosters.

## Project Overview

This application simulates the complex dynamics of a rocket booster returning from space. It runs a real-time deterministic physics engine and uses a dual-loop PID autopilot to manage vertical velocity (throttle) and angular stability (gimbal/RCS).

The core feature is the **Suicide Burn (Hoverslam)** logic, where the engine ignites at the last possible second to cancel out velocity exactly as the rocket reaches the ground, maximizing fuel efficiency.

## How It Works

### Physics Engine (`js/physics.js`)
The simulation runs a rigid body physics step integrating forces:
*   **Gravity**: Constant acceleration downwards.
*   **Thrust**: Main engine force vector, directed by the Gimbal.
*   **Torque**: Rotational force generated by Gimbal lever arm and RCS thrusters.
*   **Aerodynamics**: Linear drag and angular damping.

### Control System
The rocket is controlled by three PID (Proportional-Integral-Derivative) controllers working in parallel:

1.  **Gimbal Controller**: Maintains the rocket's upright orientation.
    *   *Input*: Current Angle vs Target Angle (0 deg).
    *   *Output*: Engine Gimbal Deflection.
2.  **RCS Controller**: Damps rotational velocity to prevent spinning.
    *   *Input*: Angular Velocity.
    *   *Output*: RCS Thruster bursts.
3.  **Throttle Controller**: Managers vertical descent rate.
    *   *Input*: Current Velocity vs Target Velocity.
    *   *Output*: Main Engine Throttle (0-100%).

### Guidance Logic (`js/guidance.js`)
The flight computer operates as a State Machine:
1.  **COAST Phase**: The rocket falls freely with the engine off to conserve fuel. The computer constantly calculates the "Stopping Distance" based on current speed and max thrust.
2.  **BURN Phase**: When Altitude < Stopping Distance (plus a safety margin), the engine ignites. The guidance system generates a target velocity profile to bring the rocket to a soft stop at h=0.
3.  **LANDED Phase**: Engine cutoff upon touchdown.

## Controls

The simulation supports both Autopilot and Manual control.

### Keyboard
*   **W / S**: Increase / Decrease Throttle.
*   **A / D**: Gimbal Engine Left / Right (Vector Thrust).
*   **Q / E**: Fire RCS Thrusters (Rotation).
*   **P**: Toggle Autopilot.
*   **R**: Reset Simulation (Spawns rocket at random position).

### Tuning Panel (Real-Time)
You can adjust guidance and control parameters on the fly:
*   **Ignition Altitude**: Sets the floor for the suicide burn trigger. Lower values create riskier, more efficient landings.
*   **Stability (Kp)**: Adjusts the stiffness of the angle controller. Higher values react faster but may oscillate.
*   **Damping (Kd)**: Adjusts the resistance to rotation change.

## Educational Value

This project visualizes why Rocket Landing is a hard problem:
*   **Non-Linearity**: As fuel burns, mass changes (simplified here), and aerodynamics vary with speed.
*   **Instability**: The "Pendulum Rocket Fallacy" applies; balancing a rocket on its engine is inherently unstable like balancing a broomstick on your hand.
*   **Timing**: A suicide burn must be precise. Igniting too late results in a crash; igniting too early wastes fuel and may cause the rocket to stop in mid-air and fall back down.

## How to Run

### Local Web Server
If you have Python installed:
```bash
python3 -m http.server 8080
```
Open `http://localhost:8080` in your browser.

### Docker
```bash
docker build -t rocket-sim .
docker run -p 8080:8080 -v $(pwd):/app rocket-sim
```
Open `http://localhost:8080`.
